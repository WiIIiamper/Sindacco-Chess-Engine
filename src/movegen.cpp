#include "defs.h"

int dirX[] = {-1, 1, 0, 0, -1, -1, 1, 1, 2, 2, 1, 1, -1, -1, -2, -2};
int dirY[] = {0, 0, -1, 1, -1, 1, -1, 1, -1, 1, 2, -2, 2, -2, -1, 1};

// Legality test for a move: makes the move, checks if
// the king is in Check and then unmakes the move.
static bool isLegalMove ( BOARD_STRUCT *pos, MOVE_STRUCT Move ) {

    bool result;
    MakeMove( Move, pos );

    if ( inCheck( 1-pos->side , pos ) )
        result = false;
    else result = true;

    UndoMove( pos );
    return result;
}

// If a piece is not pinned then it is pointless to do
// the legality test for the moves generated by that piece.
static bool isPinnedPiece ( BOARD_STRUCT *pos, int Rank, int File ) {

    int piece = pos->board[Rank][File];
    pos->board[Rank][File] = EMPTY;
    bool result = false;

    if ( inCheck( PieceSide[piece], pos ) )
        result = true;
    pos->board[Rank][File] = piece;

    return result;
}

// Adds a move to the move list and returns false if the move was illegal
static bool AddMove ( BOARD_STRUCT *pos, MoveLIST *List, int fromR, int fromF, int toR, int toF,
                     bool ep, bool castle, bool definitelyLegal) {

    List->Count++;

    List->moves[ List->Count ].from[0] = fromR;
    List->moves[ List->Count ].from[1] = fromF;
    List->moves[ List->Count ].to[0] = toR;
    List->moves[ List->Count ].to[1] = toF;
    List->moves[ List->Count ].score = 0;

    int piece = PieceType[ pos->board[ fromR ][ fromF ] ];
    List->moves[ List->Count ].captured = EMPTY;

    // Gives the move a score to improve move ordering
    if ( pos->board[toR][toF] != EMPTY ) {

        List->moves[ List->Count ].captured = pos->board[toR][toF];
        int capture = PieceType[ pos->board[toR][toF] ];
        List->moves[ List->Count ].score += Victim[ capture ];
        List->moves[ List->Count ].score += Attacker[ piece ];
        List->moves[ List->Count ].score += 1000000;
    }

    if ( ep == true )
        List->moves[ List->Count ].score = 150 + 1000000;

    List->moves[ List->Count ].ep = ep;
    List->moves[ List->Count ].castle = castle;

    List->moves[ List->Count ].promotion = NONE;

    // We must check if a move puts the king in check : then the move is illegal.
    // But for some moves we can be sure that won't happen.
    if ( !definitelyLegal ) {

        if ( !isLegalMove ( pos, List-> moves[ List->Count ] ) ) {
            List->Count--;
            return false;
        }
    }

    // Promotion
    if ( PieceType[ pos->board[fromR][fromF] ] == PAWN ) {
        if ( toR == RANK1 || toR == RANK8 ) {
            List->moves[ List->Count ].promotion = QUEEN;
            List->moves[ List->Count ].score = 550 + 1000000;

            List->Count++;
            List->moves[ List->Count ] = List->moves[ List->Count -1];
            List->moves[ List->Count ].promotion = KNIGHT;
            List->moves[ List->Count ].score = 250 + 1000000;

            List->Count++;
            List->moves[ List->Count ] = List->moves[ List->Count -1];
            List->moves[ List->Count ].promotion = ROOK;
            List->moves[ List->Count ].score = 450 + 1000000;

            List->Count++;
            List->moves[ List->Count ] = List->moves[ List->Count -1];
            List->moves[ List->Count ].promotion = BISHOP;
            List->moves[ List->Count ].score = 350 + 1000000;
        }
    }

    return true;
}

static void GenerateKnightMoves ( int RANK, int FILE, int SIDE, BOARD_STRUCT *pos, MoveLIST *List ) {

    // If a knight is pinned than it cannot move
    bool pinned = isPinnedPiece( pos, RANK, FILE );
    if ( pinned )
        return;

    for ( int l = 8; l < 16; l++ ) {
        int i = RANK + dirX[l];
        int j = FILE + dirY[l];

        if ( onBoard(i, j) ) {
            int piece = pos->board[i][j];
            if ( PieceSide[piece] != SIDE )
                AddMove( pos, List, RANK, FILE, i, j, false, false, true );
        }
    }
}

static void GenerateBishopMoves ( int RANK, int FILE, int SIDE, BOARD_STRUCT *pos, MoveLIST *List ) {

    // If a bishop is pinned than it can only move towards the attacker
    bool pinned = isPinnedPiece( pos, RANK, FILE );

    int i, j, piece;
    for ( int l = 4; l < 8; l++ ) {
        i = RANK + dirX[l];
        j = FILE + dirY[l];

        for (; OK(i, j, pos); i += dirX[l], j += dirY[l] ) {
            if ( ! AddMove( pos, List, RANK, FILE, i, j, false, false, !pinned )
                && pinned )
                    break;
        }

        if ( onBoard(i, j) ) {
            piece = pos->board[i][j];
            if ( PieceSide[ piece ] == 1-SIDE )
                AddMove( pos, List, RANK, FILE, i, j, false, false, !pinned );
        }
    }
}

static void GenerateRookMoves ( int RANK, int FILE, int SIDE, BOARD_STRUCT *pos, MoveLIST *List ) {

    // If a rook is pinned than it can only move towards the attacker
    bool pinned = isPinnedPiece( pos, RANK, FILE );

    for ( int l = 0; l < 4; l++ ) {
        int i = RANK + dirX[l];
        int j = FILE + dirY[l];

        for (; OK(i, j, pos); i += dirX[l], j += dirY[l] ) {
            if ( !AddMove( pos, List, RANK, FILE, i, j, false, false, !pinned )
                && pinned )
                    break;
        }

        if ( onBoard(i, j) ) {
            int piece = pos->board[i][j];
            if ( PieceSide[ piece ] == 1-SIDE )
                AddMove( pos, List, RANK, FILE, i, j, false, false, !pinned );
        }
    }
}

static void GenerateQueenMoves ( int RANK, int FILE, int SIDE, BOARD_STRUCT *pos, MoveLIST *List ) {

    // If a queen is pinned than it can only move towards the attacker
    bool pinned = isPinnedPiece( pos, RANK, FILE );

    for ( int l = 0; l < 8; l++ ) {
        int i = RANK + dirX[l];
        int j = FILE + dirY[l];

        for (; OK(i, j, pos); i += dirX[l], j += dirY[l] ) {
            if ( !AddMove( pos, List, RANK, FILE, i, j, false, false, !pinned )
                && pinned )
                    break;
        }

        if ( onBoard(i, j) ) {
            int piece = pos->board[i][j];
            if ( PieceSide[ piece ] == 1-SIDE )
                AddMove( pos, List, RANK, FILE, i, j, false, false, !pinned );
        }
    }
}

static void GenerateKingMoves ( int RANK, int FILE, int SIDE, BOARD_STRUCT *pos, MoveLIST *List ) {

    int k = pos->board[RANK][FILE];
    pos->board[RANK][FILE] = EMPTY;

    for ( int l = 0; l < 8; l++ ) {
        int i = RANK + dirX[l];
        int j = FILE + dirY[l];

        if ( onBoard(i, j) ) {
            if ( PieceSide[ pos->board[i][j] ] != SIDE ) {

                if ( !isSquareAttacked( i, j, 1-SIDE, pos) )
                    AddMove( pos, List, RANK, FILE, i, j, false, false, true );
            }
        }
    }

    pos->board[RANK][FILE] = k;

    // CASTLING
    if ( SIDE == WHITE && !inCheck(WHITE, pos) ) {

        if ( pos->castlePermission & WKCA) {

            if ( pos->board[RANK][FILE+1] == EMPTY && pos-> board[RANK][FILE+2] == EMPTY )
                if ( !isSquareAttacked(RANK, FILE+1, BLACK, pos) && !isSquareAttacked(RANK, FILE+2, BLACK, pos) )
                    AddMove( pos, List, RANK, FILE, RANK, FILE+2, false, true, true );
        }
        if ( pos->castlePermission & WQCA ) {

            if ( pos->board[RANK][FILE-1] == EMPTY && pos-> board[RANK][FILE-2] == EMPTY && pos-> board[RANK][FILE-3] == EMPTY )
               if ( !isSquareAttacked(RANK, FILE-1, BLACK, pos) && !isSquareAttacked(RANK, FILE-2, BLACK, pos) )
                  AddMove( pos, List, RANK, FILE, RANK, FILE-2, false, true, true );
        }
    } else if ( !inCheck( BLACK, pos ) ) {

        if ( pos->castlePermission & BKCA ) {

            if ( pos->board[RANK][FILE+1] == EMPTY && pos-> board[RANK][FILE+2] == EMPTY )
               if ( !isSquareAttacked(RANK, FILE+1, WHITE, pos) && !isSquareAttacked(RANK, FILE+2, WHITE, pos) )
                  AddMove( pos, List, RANK, FILE, RANK, FILE+2, false, true, true );
        }
        if ( pos->castlePermission & BQCA ) {

            if ( pos->board[RANK][FILE-1] == EMPTY && pos-> board[RANK][FILE-2] == EMPTY && pos-> board[RANK][FILE-3] == EMPTY )
               if ( !isSquareAttacked(RANK, FILE-1, WHITE, pos) && !isSquareAttacked(RANK, FILE-2, WHITE, pos) )
                  AddMove( pos, List, RANK, FILE, RANK, FILE-2, false, true, true );
        }
    }
}

static void GeneratePawnMoves ( int RANK, int FILE, int SIDE, BOARD_STRUCT *pos, MoveLIST *List ) {

    bool pinned = isPinnedPiece( pos, RANK, FILE );

    if ( SIDE == WHITE ) {

        if ( pos->board[ RANK-1 ][FILE] == EMPTY ) {
            AddMove( pos, List, RANK, FILE, RANK-1, FILE, false, false, !pinned );

            if ( RANK == RANK2 ) {
                if ( pos->board[ RANK-2 ][FILE] == EMPTY )
                    AddMove( pos, List, RANK, FILE, RANK-2, FILE, false, false, !pinned );
            }
        }

        // CAPTURES
        if ( onBoard( RANK-1, FILE+1 ) ) {
            if ( pos->board[RANK-1][FILE+1] != EMPTY && PieceSide[ pos->board[RANK-1][FILE+1] ] != SIDE )
                AddMove(pos, List, RANK, FILE, RANK-1, FILE+1, false, false, !pinned);
        }
        if ( onBoard( RANK-1, FILE-1 ) ) {
            if ( pos->board[RANK-1][FILE-1] != EMPTY && PieceSide[ pos->board[RANK-1][FILE-1] ] != SIDE )
                AddMove(pos, List, RANK, FILE, RANK-1, FILE-1, false, false, !pinned);
        }

        // ENPASSANT MOVES
        if ( onBoard( RANK-1, FILE+1 ) ) {
            if ( RANK-1 == pos->enPass[0] && FILE+1 == pos->enPass[1] )
                AddMove(pos, List, RANK, FILE, RANK-1, FILE+1, true, false, false);
        }
        if ( onBoard( RANK-1, FILE-1 ) ) {
            if ( RANK-1 == pos->enPass[0] && FILE-1 == pos->enPass[1] )
                AddMove(pos, List, RANK, FILE, RANK-1, FILE-1, true, false, false);
        }
    } else {

        if ( pos->board[ RANK+1 ][FILE] == EMPTY ) {
            AddMove( pos, List, RANK, FILE, RANK+1, FILE, false, false, !pinned);

            if ( RANK == RANK7 ) {
                if ( pos->board[ RANK+2 ][FILE] == EMPTY )
                    AddMove( pos, List, RANK, FILE, RANK+2, FILE, false, false, !pinned);
            }
        }

        // CAPTURES
        if ( onBoard( RANK+1, FILE+1 ) ) {
            if ( pos->board[RANK+1][FILE+1] != EMPTY && PieceSide[ pos->board[RANK+1][FILE+1] ] != SIDE )
                AddMove(pos, List, RANK, FILE, RANK+1, FILE+1, false, false, !pinned);
        }
        if ( onBoard( RANK+1, FILE-1 ) ) {
            if ( pos->board[RANK+1][FILE-1] != EMPTY && PieceSide[ pos->board[RANK+1][FILE-1] ] != SIDE )
                AddMove(pos, List, RANK, FILE, RANK+1, FILE-1, false, false, !pinned);
        }

        // ENPASSANT MOVES
        if ( onBoard( RANK+1, FILE+1 ) ) {
            if ( RANK+1 == pos->enPass[0] && FILE+1 == pos->enPass[1] )
                AddMove(pos, List, RANK, FILE, RANK+1, FILE+1, true, false, false);
        }
        if ( onBoard( RANK+1, FILE-1 ) ) {
            if ( RANK+1 == pos->enPass[0] && FILE-1 == pos->enPass[1] )
                AddMove(pos, List, RANK, FILE, RANK+1, FILE-1, true, false, false);
        }
    }
}

static void GenerateCheckEvasions( int Side, BOARD_STRUCT *pos, MoveLIST *List );

void GenerateAllMoves ( int SIDE, BOARD_STRUCT *pos, MoveLIST *List ) {
    List->Count = 0;

    if ( inCheck( SIDE, pos ) ) {
        GenerateCheckEvasions( SIDE, pos, List );
        return;
    }

    int lo, hi;
    if ( SIDE == WHITE )
        lo = 1, hi = 6;
    else if ( SIDE == BLACK ) lo = 7, hi = 12;

    for ( int piece = lo; piece <= hi; piece++ ) {
        for ( int cnt = 0; cnt < pos->pieceNum[piece]; cnt++ ) {

            int Rank = pos->pieces[piece][cnt][0];
            int File = pos->pieces[piece][cnt][1];
            switch ( PieceType[piece]  ) {
                case PAWN: GeneratePawnMoves(Rank, File, SIDE, pos, List); break;
                case KNIGHT: GenerateKnightMoves(Rank, File, SIDE, pos, List); break;
                case BISHOP: GenerateBishopMoves(Rank, File, SIDE, pos, List); break;
                case ROOK: GenerateRookMoves(Rank, File, SIDE, pos, List); break;
                case QUEEN: GenerateQueenMoves(Rank, File, SIDE, pos, List); break;
                case KING: GenerateKingMoves(Rank, File, SIDE, pos, List); break;
            }
        }
    }
}

// If the side to move is in check, we can generate evasions in a more
// efficient way by ignoring moves that won't get the king out of check.
static void GenerateCheckEvasions ( int Side, BOARD_STRUCT *pos, MoveLIST *List ) {

    int numCheckers = 0;
    int evasionSquares[8][8] = {0};
    int k = Side == WHITE ? wK : bK;
    int Rank = pos->pieces[k][0][0], File = pos->pieces[k][0][1];

    // First step is to get the number of checkers and generate the squares
    // where a piece would need to be moved in order to either block the check
    // or to capture the attacker.
    for ( int l = 0; l < 8; l++ ) {
        int i = Rank + dirX[l];
        int j = File + dirY[l];

        for (; OK(i, j, pos); i += dirX[l], j += dirY[l] );

        if ( onBoard( i, j ) ) {
            int piece = pos->board[i][j];
            if ( PieceSide[piece] == 1-Side ) {

                    if ( PieceType[ piece ] == QUEEN ||
                        ( l < 4 && PieceType[piece] == ROOK ) ||
                        ( l >= 4 && PieceType[piece] == BISHOP ) ) {

                        numCheckers++;
                        for ( ; i != Rank || j != File; i -= dirX[l], j -= dirY[l] )
                            evasionSquares[i][j] = 1;
                }
            }
        }
    }

    for ( int l = 8; l < 16; l++ ) {
        int i = Rank + dirX[l];
        int j = File + dirY[l];

        if ( onBoard(i, j) ) {
            int piece = pos->board[i][j];
            if ( PieceSide[piece] == 1-Side && PieceType[piece] == KNIGHT ) {
                numCheckers++;
                evasionSquares[i][j] = 1;
            }
        }
    }

    if ( Side == BLACK ) {

        if ( onBoard(Rank+1, File+1) ) {
            int Piece = pos->board[ Rank+1 ][ File+1 ];
            if ( PieceType[ Piece ] == PAWN && PieceSide[ Piece ] == 1-Side )
                evasionSquares[ Rank+1 ][ File+1 ] = 1, numCheckers++;
        }
        if ( onBoard(Rank+1, File-1) ) {
            int Piece = pos->board[ Rank+1 ][ File-1 ];
            if ( PieceType[ Piece ] == PAWN && PieceSide[ Piece ] == 1-Side )
                evasionSquares[ Rank+1 ][ File-1 ] = 1, numCheckers++;
        }
    } else {

        if ( onBoard(Rank-1, File+1) ) {
            int Piece = pos->board[ Rank-1 ][ File+1 ];
            if ( PieceType[ Piece ] == PAWN && PieceSide[ Piece ] == 1-Side )
                evasionSquares[ Rank-1 ][ File+1 ] = 1, numCheckers++;
        }
        if ( onBoard(Rank-1, File-1) ) {
            int Piece = pos->board[ Rank-1 ][ File-1 ];
            if ( PieceType[ Piece ] == PAWN && PieceSide[ Piece ] == 1-Side )
                evasionSquares[ Rank-1 ][ File-1 ] = 1, numCheckers++;
        }
    }

    // If the king is in double check then the
    // only legal moves are king moves
    if ( numCheckers > 1 )
        GenerateKingMoves( Rank, File, Side, pos, List );
    else {

        /* If the king is not in double check then we can only do the legality test
        to moves that will either capture the checking piece or block his attack
        if the attacker is a slider */

        int lo, hi;
        if ( Side == WHITE )
            lo = 1, hi = 6;
        else lo = 7, hi = 12;

        for ( int piece = lo; piece <= hi; piece++ ) {
            for ( int cnt = 0; cnt < pos->pieceNum[piece]; cnt++ ) {

                int RANK = pos->pieces[piece][cnt][0];
                int FILE = pos->pieces[piece][cnt][1];

                if ( PieceType[piece] == PAWN ) {

                    if ( Side == WHITE ) {

                        if ( pos->board[ RANK-1 ][FILE] == EMPTY ) {

                            if ( evasionSquares[ RANK-1 ][FILE] )
                                AddMove( pos, List, RANK, FILE, RANK-1, FILE, false, false, false );

                            if ( RANK == RANK2 ) {
                                if ( pos->board[ RANK-2 ][FILE] == EMPTY
                                    && evasionSquares[ RANK-2 ][FILE] )
                                    AddMove( pos, List, RANK, FILE, RANK-2, FILE, false, false, false );
                            }
                        }

                        // CAPTURES
                        if ( onBoard( RANK-1, FILE+1 ) ) {
                            if ( pos->board[RANK-1][FILE+1] != EMPTY && PieceSide[ pos->board[RANK-1][FILE+1] ] != Side
                                && evasionSquares[ RANK-1 ][ FILE+1 ] )
                                AddMove(pos, List, RANK, FILE, RANK-1, FILE+1, false, false, false);
                        }
                        if ( onBoard( RANK-1, FILE-1 ) ) {
                            if ( pos->board[RANK-1][FILE-1] != EMPTY && PieceSide[ pos->board[RANK-1][FILE-1] ] != Side
                                && evasionSquares[ RANK-1 ][ FILE-1 ] )
                                AddMove(pos, List, RANK, FILE, RANK-1, FILE-1, false, false, false);
                        }

                        // ENPASSANT MOVES
                        if ( onBoard( RANK-1, FILE+1 ) ) {
                            if ( RANK-1 == pos->enPass[0] && FILE+1 == pos->enPass[1] )
                                AddMove(pos, List, RANK, FILE, RANK-1, FILE+1, true, false, false);
                        }
                        if ( onBoard( RANK-1, FILE-1 ) ) {
                            if ( RANK-1 == pos->enPass[0] && FILE-1 == pos->enPass[1] )
                                AddMove(pos, List, RANK, FILE, RANK-1, FILE-1, true, false, false);
                        }
                    } else {

                        if ( pos->board[ RANK+1 ][FILE] == EMPTY ) {

                            if ( evasionSquares[ RANK+1 ][FILE] )
                                AddMove( pos, List, RANK, FILE, RANK+1, FILE, false, false, false);

                            if ( RANK == RANK7 ) {
                                if ( pos->board[ RANK+2 ][FILE] == EMPTY
                                    && evasionSquares[RANK+2][FILE] )
                                    AddMove( pos, List, RANK, FILE, RANK+2, FILE, false, false, false);
                            }
                        }

                        // CAPTURES
                        if ( onBoard( RANK+1, FILE+1 ) ) {
                            if ( pos->board[RANK+1][FILE+1] != EMPTY && PieceSide[ pos->board[RANK+1][FILE+1] ] != Side
                                && evasionSquares[ RANK+1 ][ FILE+1 ] )
                                AddMove(pos, List, RANK, FILE, RANK+1, FILE+1, false, false, false);
                        }
                        if ( onBoard( RANK+1, FILE-1 ) ) {
                            if ( pos->board[RANK+1][FILE-1] != EMPTY && PieceSide[ pos->board[RANK+1][FILE-1] ] != Side
                                && evasionSquares[ RANK+1 ][ FILE-1 ] )
                                AddMove(pos, List, RANK, FILE, RANK+1, FILE-1, false, false, false);
                        }

                        // ENPASSANT MOVES
                        if ( onBoard( RANK+1, FILE+1 ) ) {
                            if ( RANK+1 == pos->enPass[0] && FILE+1 == pos->enPass[1] )
                                AddMove(pos, List, RANK, FILE, RANK+1, FILE+1, true, false, false);
                        }
                        if ( onBoard( RANK+1, FILE-1 ) ) {
                            if ( RANK+1 == pos->enPass[0] && FILE-1 == pos->enPass[1] )
                                AddMove(pos, List, RANK, FILE, RANK+1, FILE-1, true, false, false);
                        }
                    }

                } else if ( PieceType[ piece ] == KNIGHT ) {

                for ( int l = 8; l < 16; l++ ) {
                    int i = RANK + dirX[l];
                    int j = FILE + dirY[l];

                    if ( onBoard(i, j) ) {
                        if ( PieceSide[ pos->board[i][j] ] != Side
                            && evasionSquares[i][j] == 1 )
                            AddMove( pos, List, RANK, FILE, i, j, false, false, false );
                    }
                }
            } else if ( PieceType[ piece ] == ROOK ) {

                for ( int l = 0; l < 4; l++ ) {
                    int i = RANK + dirX[l];
                    int j = FILE + dirY[l];

                    for (; OK(i, j, pos); i += dirX[l], j += dirY[l] )
                        if ( evasionSquares[i][j] )
                            AddMove( pos, List, RANK, FILE, i, j, false, false, false );

                    if ( onBoard(i, j) ) {
                        if ( PieceSide[ pos->board[i][j] ] != Side
                            && evasionSquares[i][j] == 1 )
                            AddMove( pos, List, RANK, FILE, i, j, false, false, false );
                    }
                }
            } else if ( PieceType[ piece ] == BISHOP ) {

                for ( int l = 4; l < 8; l++ ) {
                    int i = RANK + dirX[l];
                    int j = FILE + dirY[l];

                    for (; OK(i, j, pos); i += dirX[l], j += dirY[l] )
                        if ( evasionSquares[i][j] )
                            AddMove( pos, List, RANK, FILE, i, j, false, false, false );

                    if ( onBoard(i, j) ) {
                        if ( PieceSide[ pos->board[i][j] ] != Side )
                                AddMove( pos, List, RANK, FILE, i, j, false, false, false );
                    }
                }
            } else if ( PieceType[ piece ] == QUEEN ) {

                for ( int l = 0; l < 8; l++ ) {
                    int i = RANK + dirX[l];
                    int j = FILE + dirY[l];

                    for (; OK(i, j, pos); i += dirX[l], j += dirY[l] )
                        if ( evasionSquares[i][j] )
                            AddMove( pos, List, RANK, FILE, i, j, false, false, false );

                    if ( onBoard(i, j) ) {
                        if ( PieceSide[ pos->board[i][j] ] == 1-Side )
                            AddMove( pos, List, RANK, FILE, i, j, false, false, false );
                    }
                }
            } else if ( PieceType[ piece ] == KING )
                GenerateKingMoves(RANK, FILE, Side, pos, List);
            }
        }
    }
}

// In qserch() we only need to generate the captures so we don't need to
// do the legality test on quiet moves.
void GenerateCaptures ( BOARD_STRUCT *pos, MoveLIST *List ) {

    int SIDE = pos->side;
    List->Count = 0;

    int lo, hi;
    if ( SIDE == WHITE )
        lo = 1, hi = 6;
    else lo = 7, hi = 12;

    for ( int piece = lo; piece <= hi; piece++ ) {
        for ( int cnt = 0; cnt < pos->pieceNum[piece]; cnt++ ) {

            int RANK = pos->pieces[piece][cnt][0];
            int FILE = pos->pieces[piece][cnt][1];

            if ( PieceType[ piece ] == PAWN ) {

                if ( SIDE == WHITE ) {

                    // CAPTURES
                    if ( onBoard( RANK-1, FILE+1 ) ) {
                        if ( pos->board[RANK-1][FILE+1] != EMPTY && PieceSide[ pos->board[RANK-1][FILE+1] ] != SIDE )
                            AddMove(pos, List, RANK, FILE, RANK-1, FILE+1, false, false, false);
                    }
                    if ( onBoard( RANK-1, FILE-1 ) ) {
                        if ( pos->board[RANK-1][FILE-1] != EMPTY && PieceSide[ pos->board[RANK-1][FILE-1] ] != SIDE )
                            AddMove(pos, List, RANK, FILE, RANK-1, FILE-1, false, false, false);
                    }

                    // ENPASSANT MOVES
                    if ( onBoard( RANK-1, FILE+1 ) ) {
                        if ( RANK-1 == pos->enPass[0] && FILE+1 == pos->enPass[1] )
                            AddMove(pos, List, RANK, FILE, RANK-1, FILE+1, true, false, false);
                    }
                    if ( onBoard( RANK-1, FILE-1 ) ) {
                        if ( RANK-1 == pos->enPass[0] && FILE-1 == pos->enPass[1] )
                            AddMove(pos, List, RANK, FILE, RANK-1, FILE-1, true, false, false);
                    }
                } else {

                    // CAPTURES
                    if ( onBoard( RANK+1, FILE+1 ) ) {
                        if ( pos->board[RANK+1][FILE+1] != EMPTY && PieceSide[ pos->board[RANK+1][FILE+1] ] != SIDE )
                            AddMove(pos, List, RANK, FILE, RANK+1, FILE+1, false, false, false);
                    }
                    if ( onBoard( RANK+1, FILE-1 ) ) {
                        if ( pos->board[RANK+1][FILE-1] != EMPTY && PieceSide[ pos->board[RANK+1][FILE-1] ] != SIDE )
                            AddMove(pos, List, RANK, FILE, RANK+1, FILE-1, false, false, false);
                    }

                    // ENPASSANT MOVES
                    if ( onBoard( RANK+1, FILE+1 ) ) {
                        if ( RANK+1 == pos->enPass[0] && FILE+1 == pos->enPass[1] )
                            AddMove(pos, List, RANK, FILE, RANK+1, FILE+1, true, false, false);
                    }
                    if ( onBoard( RANK+1, FILE-1 ) ) {
                        if ( RANK+1 == pos->enPass[0] && FILE-1 == pos->enPass[1] )
                            AddMove(pos, List, RANK, FILE, RANK+1, FILE-1, true, false, false);
                    }
                }
            } else if ( PieceType[ piece ] == KNIGHT ) {

                for ( int l = 8; l < 16; l++ ) {
                    int i = RANK + dirX[l];
                    int j = FILE + dirY[l];

                    if ( onBoard(i, j) ) {
                        if ( PieceSide[ pos->board[i][j] ] == 1-SIDE )
                            AddMove( pos, List, RANK, FILE, i, j, false, false, false );
                    }
                }
            } else if ( PieceType[ piece ] == ROOK ) {

                for ( int l = 0; l < 4; l++ ) {
                    int i = RANK + dirX[l];
                    int j = FILE + dirY[l];

                    for (; OK(i, j, pos); i += dirX[l], j += dirY[l] ) ;

                    if ( onBoard(i, j) ) {
                        if ( PieceSide[ pos->board[i][j] ] == 1-SIDE )
                            AddMove( pos, List, RANK, FILE, i, j, false, false, false );
                    }
                }
            } else if ( PieceType[ piece ] == BISHOP ) {

                for ( int l = 4; l < 8; l++ ) {
                    int i = RANK + dirX[l];
                    int j = FILE + dirY[l];

                    for (; OK(i, j, pos); i += dirX[l], j += dirY[l] );

                    if ( onBoard(i, j) ) {
                        if ( PieceSide[ pos->board[i][j] ] == 1-SIDE )
                                AddMove( pos, List, RANK, FILE, i, j, false, false, false );
                    }
                }
            } else if ( PieceType[ piece ] == QUEEN ) {

                for ( int l = 0; l < 8; l++ ) {
                    int i = RANK + dirX[l];
                    int j = FILE + dirY[l];

                    for (; OK(i, j, pos); i += dirX[l], j += dirY[l] );

                    if ( onBoard(i, j) ) {
                        if ( PieceSide[ pos->board[i][j] ] == 1-SIDE )
                            AddMove( pos, List, RANK, FILE, i, j, false, false, false );
                    }
                }
            } else if ( PieceType[ piece ] == KING ) {

                int k = pos->board[RANK][FILE];
                pos->board[RANK][FILE] = EMPTY;

                for ( int l = 0; l < 8; l++ ) {
                    int i = RANK + dirX[l];
                    int j = FILE + dirY[l];

                    if ( onBoard(i, j) ) {
                        if ( PieceSide[ pos->board[i][j] ] == 1-SIDE )
                            if ( !isSquareAttacked( i, j, 1-SIDE, pos) )
                                AddMove( pos, List, RANK, FILE, i, j, false, false, true );
                    }
                }

                pos->board[RANK][FILE] = k;
            }
        }
    }
}
